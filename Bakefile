#!/bin/bash 

SRC=src
DIST=dist
TEMPLATES=templates
REMOTE=s11
DOMAIN=roblog.nl

FORMAT="prettier --ignore-path .prettierignore"
# TODO(robin): fork this and make it a proper node binary
VALIDATE="java -jar node_modules/vnu-jar/build/dist/vnu.jar --exit-zero-always --filterfile .vnuignore"
DEPLOY="rsync -ciavuP --delete --exclude canvas.json"

# Bakery configuration
export TITLE="Robin (axcelott)"
export BIO="Thoughts and opinions of a teenager from the Netherlands."
export CANONICAL="$DOMAIN"
export LICENSE="https://creativecommons.org/publicdomain/zero/1.0/"
export LANGUAGE="en"
export AUTHOR="Robin Boers"
export EMAIL="webmaster@roblog.nl"
export RIGHTS="Copying is an act of love. Please copy."
export STYLESHEET="/main.css?v=$(md5sum $SRC/main.css | awk '{print $1}')"
export FORMATTER="$FORMAT --write"

setup() {
  bun i
}

deploy() {
  if [ -d $DIST ]; then
    $DEPLOY $DIST/ $REMOTE:domains/$DOMAIN/public_html
  else
    echo >&2 "Error: '$DIST' does not exist."
    echo >&2
  fi
}

format() {
  $FORMAT --write $SRC
}

build() {
  bakery build $SRC $DIST

  # My canonical URLs are without the .html suffix.
  sed -i 's/\.html//g' "$DIST/sitemap.xml"
}

mentions() {
  for file in "$DIST/blog"/*.html; do
    local id="$(basename "$file" .html | md5sum | awk '{print $1}')"
    local state="$HOME/.local/state/mentions/$id"

    if [ "$(basename "$file")" == "index.html" ]; then
      continue
    fi

    if [ ! -e "$state" ]; then
      local out="$(wm "$file")"
      local none="No webmention endpoints found on 1 entries found (try increasing with --limit N)"

      if [ "$out" == "$none" ]; then
        continue
      fi
      
      echo "Wanna send the following mentions for '$(basename "$file")'?"
      echo "$out"
      echo

      if prompt -y; then
        wm "$file" --send
      fi

      touch "$state"
    fi
  done
}

serve() {
  cd $DIST
  waiter --dev
}

dev() {
  bakery watch $SRC $DIST &
  trap "kill $!" SIGINT
  mkdir -p $DIST && cd $DIST
  waiter --dev
}

clean() {
  rm -rf $DIST
  rm -rf node_modules bun.lockb
}

check() {
  echo
  echo "Running formatter"
  $FORMAT --check $DIST

  echo
  echo "Running validators"
  $VALIDATE --skip-non-html --also-check-css $DIST && echo "No issues."
  
  echo
  echo "Running stylelint"
  stylelint "$DIST/**/*.css" && echo "No issues."

  echo
  echo "Running achecker"
  achecker $DIST

  # BLOCKED: htmltest doesn't yet support pretty URLs like I have,
  # see https://github.com/wjdp/htmltest/issues/183

  # echo
  # echo "Running htmltest"
  # htmltest
}

new() {
  p:get "Title" TITLE
  p:get_with_default "Language" LANGUAGE "en"
  p:get_with_default "Path" URL "$(sluggify "$TITLE")" 

  export PARENT="/"
  export CONTENT="<!-- CONTENT HERE -->"

  p:write "page.html"
}

publish() {
  local draft="$1"

  if [ -e "$draft" ]; then
    p:get "Title" TITLE
    p:get_with_default "Date" DATE "$(date +"%Y-%m-%d")"
    p:get_with_default "Language" LANGUAGE "en"

    export PARENT="/blog"
    export URL="blog/$(basename "${1%.*}")"
    export CONTENT="$(cat "$draft")"

    export DATE_SHORT="$(date -d "$DATE" +"%Y-%m-%d")"
    export DATE_LONG="$(date -d "$DATE" +"%b %d, %Y")"

    p:list
    p:write "post.html"
  else
    err "'$draft' doesn't exist."
  fi
}

# Writes a page to the $SRC directory.
p:write() {
  local dist="$SRC/$URL.html"

  [ -f "$dist" ] && err "'$dist' already exists."

  mkdir -p "$(dirname "$dist")"

  # Render sub-template
  export CONTENT="$(p:render "$1")"
  # Render into base template
  p:render "base.html" > "$dist"

  $FORMAT --write "$dist" >/dev/null
}

# Appends a post to the posts listings.
p:list() {
  local C="$(p:render "h-entry.html" | p:sed_escape)"
  sed -i /'<!-- INSERT NEW POSTS HERE -->'/a\\"$C" "$SRC/blog/index.html"
}

# Renders a template in the $TEMPLATES directory.
p:render() {
  export CANONICAL="$DOMAIN"
  cat "$TEMPLATES/$1" | envsubst
}

p:get() {
  # Return if $2 is already set.
  [ -v $2 ] && return

  printf "\n$1: "
  read $2
  export $2

  if [ -z "${!2}" ]; then
    err "you didn't provide $1."
  fi
}

p:get_with_default() {
  [ -v $2 ] && return

  printf "\n$1 [$3]: "
  read $2
  export $2

  if [ "${!2}" = "" ]; then
    eval "export $2='$3'"
  fi
}

p:sed_escape() {
  sed -e 's/^[[:space:]]*//;s/[[:space:]]*$//;s/\//\\\//g' | tr '\n' ' ' 
}
